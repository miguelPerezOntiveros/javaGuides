# Chapter 8: String Processing, Data Formatting and Resource Bundles

### Dates, Numbers, Currencies and Locales

###### java.util.Date
- is here for legacy purposes
- if you want to create an instance of Date to represent "now," you use Date's no-argument constructor:
- .getTime() and .setTime()

###### java.util.Calendar
- it is an abstract class. You have to use one of the overloaded getInstance() static factory methods. java.util.GregorianCalendar is what you'll almost certainly get.
- Days of the week: 'Calendar.SUNDAY'.
- c.getFirstDayOfWeek() lets you know what the first day of the week is, it may or may not be Sunday. In some locales, MONDAY is the first day of the week.
- c.get(Calendar.DAY_OF_WEEK)); lets you get the day of the week c is.
- Calendar's add() method lets you add or substract time. c.add(Calendar.HOUR, -4);.
- to convert a calendar back to a date: Date d2 = c.getTime();.
- The other Calendar method you should know for the exam is the roll() method. The roll() method acts like the add() method, except that when a part of a Date gets incremented or decremented, larger parts of the Date will not get incremented or decremented.

###### java.util.DateFormat
- --TODO--

###### java.util.NumberFormat
- --TODO--

###### java.util.Locale
- requiered for date or number formating in a specific locale.
- --TODO--

### Parsing,Tokenizing, and Formatting

##### Finding stuff
- We will use _java.util.regex.Pattern_ and _java.util.regex.Matcher_
- Regular expressions (regex for short) are a kind of language (It's fair to think of regex as a language) within a language, designed to help programmers with these searching tasks. 
- Example: searching _ab_ in _abaaaba_, regex engine,  would reply by telling us that it found matches at positions 0 and 4.
source: abababa
index:  0123456
expression: aba
 0 and another starting at position 4. But how about starting at position 2? In general in the world of regex, the aba string that starts at position 2 will not be considered a valid occurrence. t the first three characters of the source were consumed. 
 In general, a regex search runs from left to right, and once a source's character has been used in a match, it cannot be reused.

de la pag 482 
import java.util.regex.*;
class RegTest {
  public static void main(String [] args) {
    Pattern p = Pattern.compile(args[0]);
    Matcher m = p.matcher(args[1]);
    System.out.println("\nsource: " + args[1]);
    System.out.println(" index: 01234567890123456\n");  // the index
    System.out.println("expression: " + m.pattern());
    System.out.print("match positions: ");
    while(m.find()) {
      System.out.print(m.start() + " ");
    }
    System.out.println("");
  }
}

##### Search using Metacharacters
- \d
	java RegTest "\\d" "a12c3e456f"
                  source: a12c3e456f
                  index: 01234567890123456
                  expression: \d
                  match positions: 1 2 4 6 7 8
- \D A non-digit (anything BUT 0–9)
- \s A whitespace character (e.g. space, \t, \n, \f, \r)
- \S A non-whitespace character
- \w A word character (letters (a–z and A–Z), digits, or the "_" [underscore])
	- "word characters" are A–Z, a–z, and 0–9
	   java RegTest "\\S" "w1w w$ &#w1"
   source: w1w w$ &#w1
    index: 01234567890123456
   expression: \S
   match positions: 0 1 2 4 5 7 8 9 10


- \W A non-word character (everything else)
- \b A word "boundary" (ends of the string and between \w and not \w—more soon)
	- the ends of the strings are considered to be "non-word" characters
	java RegTest "\\b" "w2w w$ &#w2"
	source: w2w w$ &#w2
	index: 01234567890123456
	expression: \b
	match positions: 0 3 4 5 9 11

- \B A non-word "boundary" (between two \w's or two not \w's)
	- But the matches on positions 0 and 11 are a bit confusing. For the sake of the exam, just imagine that for \b and \B, there is a hidden, non-word character at each end of the string that you can see.
	source: "a 1 56 _Z"
	index:   012345678
	pattern: \w
	regex will return positions 0, 2, 4, 5, 7, and 8

	source: #ab de#
	index: 01234567890123456
	expression: \b
	match positions: 1 3 4 6
- the dot operator: "any character can serve here." 
	source: "ac abc a c"
	pattern: a.c
	will produce the output
	3 abc 7a c

##### Search using Ranges
- [abc] Searches only for a's, b's, or c's
- [a-f] Searches only for a, b, c, d, e, or f characters
- [a-fA-F] Searches for the first six letters of the alphabet, both cases.

	source: "cafeBABE"
	index:   01234567
	pattern: [a-cA-C]
	returns positions 0, 1, 4, 5, 6.

- "^" to negate the characters specified, nested brackets to create a union of sets, and "&&"
to specify the intersection of sets.While these constructs are not on the exam, they are quite useful, and good examples can be found in the API for the java.util.regex.Pattern class.

##### Search using Quantifiers
- Example: hexadecimal literals
	0[xX][0-9a-fA-F]
	The preceding expression could be stated:
	Find a set of characters in which the first character is a "0", the second character is either an "x" or an "X", and the third character is a digit from "0" to "9", a letter from "a" to "f", or an uppercase letter from "A" to "F".

	source: 12 0x 0x12 0Xf 0xg
	index: 012345678901234567
	regex would return 6 and 11. (Note: 0x and 0xg are not valid hex numbers.)

##### Groups 

- * Zero or more occurrences
- ? Zero or one occurrence

- to separate proyects:
	..."proj3.txt,proj1sched.pdf,proj1,proj2,proj1.java"...
	proj1([^,])* (give me zero or more characters that aren't a comma.")
	10 proj1sched.pdf
	25 proj1
	37 proj1.java

- to find phone numbers:
	1234567
	123 4567
	123-4567
	"zero or one instance of either a space or a dash" in the middle of our digits:
	\d\d\d([-\s])?\d\d\d\d

##### Greedy Quantifiers
- When you use the *, +, and ? quantifiers, you can fine-tune them a bit to produce behavior that's known as 
	- "greedy,"
	- "reluctant,"
	- "possessive."
- -to do-

##### When Metacharacters and Strings Collide
- -to do-

##### Locating Data via Pattern Matching
- -to do-

##### Searching Using the Scanner Class
- -to do-

##### Tokenizing stuff
- String.split()
	- -to do-
- java.util.Scanner
	- -to do-
- java.util.StringTokenizer
	- -to do-

##### Formating stuff
- java.util.Formatter
- printf() and format()

### Resource Bundles
- Property Resource Bundles
	- -to do-
- Java Resource Bundles
	- -to do-
- Default Locale
	- -to do-